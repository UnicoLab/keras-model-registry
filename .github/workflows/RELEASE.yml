name: "Semantic Release"

on:
  workflow_dispatch:
    inputs:
      DRY_RUN:
        type: boolean
        required: false
        description: "Run in dry run mode (no actual release)"

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  SEMANTIC_RELEASE:
    runs-on: ["ubuntu-latest"]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: "Semantic Release"
        id: semantic-release
        uses: "UnicoLab/KerasFactory/.github/templates/github/semantic_release@main"
        with:
          PROJECT_NAME: KerasFactory
          PROJECT_DIRECTORY: .
          BRANCHES: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ inputs.DRY_RUN }}

      - name: "testing TAG fetch"
        shell: bash
        run: |
          echo "CURRENT TAG:"
          echo ${{ steps.semantic-release.outputs.new_release_version }}
          echo "CURRENT Notes:"
          echo ${{ steps.semantic-release.outputs.new_release_notes }}

      - name: Set up Python
        if: steps.semantic-release.outcome == 'success'
        uses: actions/setup-python@v5
        with:
          python-version: 3.11

      - name: Install Python dependencies
        shell: bash
        run: |
          # updating python
          python -m pip install --upgrade pip

          # installing poetry
          pip install poetry

          # disable venvs
          poetry config virtualenvs.create false

          # assuring we have all extras for testing as well
          poetry install --all-extras --no-interaction

          # Verify mike is installed
          mike --version || pip install mike

      - name: Publishing to PyPI
        shell: bash
        run: |
          # Configuring PyPi
          poetry config pypi-token.pypi ${{ secrets.PYPI_TOKEN }}

          # Setting correct package version (from semantic-release)
          # Semantic-release creates tags with 'v' prefix (e.g., v0.1.0)
          RELEASE_VERSION="${{ steps.semantic-release.outputs.new_release_version }}"
          # Remove 'v' prefix for poetry version (poetry expects version without prefix)
          VERSION_WITHOUT_V="${RELEASE_VERSION#v}"
          echo "Updating poetry version to: $VERSION_WITHOUT_V (from semantic-release tag: $RELEASE_VERSION)"
          poetry version "$VERSION_WITHOUT_V"
          
          # Fetch latest changes (semantic-release may have pushed CHANGELOG.md and created a tag)
          git fetch origin main --tags || true
          
          # Commit pyproject.toml update back to repo to keep it synchronized
          # This ensures pyproject.toml always matches the released version
          # Note: This commit happens after semantic-release's tag, but that's okay -
          # the important thing is pyproject.toml matches the released version
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git add pyproject.toml
          if git diff --staged --quiet; then
            echo "✓ pyproject.toml already matches semantic-release version: $VERSION_WITHOUT_V"
          else
            echo "Committing pyproject.toml version update to keep repo synchronized"
            git commit -m "chore: sync version to $VERSION_WITHOUT_V [skip ci]" || echo "Commit failed (may already be committed)"
            # Try to push, but don't fail if there are conflicts (manual resolution may be needed)
            git push origin HEAD:main || echo "Warning: Push failed - pyproject.toml may need manual sync"
          fi

          # Publishing to PyPi (will use the version we just set)
          echo "Publishing to PyPI with version: $VERSION_WITHOUT_V (tag: $RELEASE_VERSION)"
          poetry publish --build

      - name: "Verify GitHub Release Created"
        if: steps.semantic-release.outcome == 'success'
        shell: bash
        run: |
          RELEASE_VERSION="${{ steps.semantic-release.outputs.new_release_version }}"
          RELEASE_NOTES="${{ steps.semantic-release.outputs.new_release_notes }}"
          echo "Semantic-release should have created:"
          echo "  - Git tag: $RELEASE_VERSION"
          echo "  - GitHub Release with release notes"
          echo ""
          echo "Release notes preview:"
          echo "$RELEASE_NOTES"

      - name: Configure Git for docs deployment
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Fetch gh-pages branch
        run: |
          # Fetch the gh-pages branch (create it if it doesn't exist)
          git fetch origin gh-pages:gh-pages 2>/dev/null || git checkout -b gh-pages && git push origin gh-pages && git checkout main

      - name: "Releasing new documentation with mike"
        id: deploy_docs
        continue-on-error: true
        shell: bash
        run: |
          # Get version from semantic-release (determined from commits)
          # Semantic-release creates tags with 'v' prefix (e.g., v0.1.0)
          RELEASE_VERSION="${{ steps.semantic-release.outputs.new_release_version }}"
          # Remove 'v' prefix for mike deployment
          VERSION="${RELEASE_VERSION#v}"
          
          # Verify version matches poetry version (should match after line 70 update)
          POETRY_VERSION=$(poetry version -s)
          if [ "$VERSION" != "$POETRY_VERSION" ]; then
            echo "Error: Semantic-release version ($VERSION) does not match poetry version ($POETRY_VERSION)"
            echo "This should not happen - using poetry version as source of truth: $POETRY_VERSION"
            VERSION="$POETRY_VERSION"
          else
            echo "✓ Version consistency verified: $VERSION (tag: $RELEASE_VERSION)"
          fi
          
          echo "Deploying documentation version: $VERSION (from semantic-release tag: $RELEASE_VERSION, matches PyPI)"
          # Configure git authentication for mike
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          mike deploy --push --update-aliases "$VERSION" latest

      - name: Retry documentation release on failure
        if: steps.deploy_docs.outcome == 'failure'
        shell: bash
        run: |
          echo "First documentation deploy attempt failed, retrying..."

          # Try to fetch the latest gh-pages branch, create if it doesn't exist
          if ! git fetch origin gh-pages:gh-pages --force 2>/dev/null; then
            echo "gh-pages branch doesn't exist, creating it..."
            git checkout --orphan gh-pages
            git rm -rf .
            git commit --allow-empty -m "Initialize gh-pages branch"
            git push origin gh-pages
            git checkout main
            git fetch origin gh-pages:gh-pages
          fi

          RELEASE_VERSION="${{ steps.semantic-release.outputs.new_release_version }}"
          VERSION="${RELEASE_VERSION#v}"
          POETRY_VERSION=$(poetry version -s)
          if [ "$VERSION" != "$POETRY_VERSION" ]; then
            VERSION="$POETRY_VERSION"
          fi
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          mike deploy --push --update-aliases --force "$VERSION" latest
